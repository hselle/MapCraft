README.txt

MapCraft
By Harrison Selle and Nick Crews

Generate real world terrain within Python Minecraft knockoff

package contents:
maindynamic:
the version of minecraft which dynamically loades elevation data from SRTM dataset

elevation.py:
Used by maindynamic to get the elevation data

heightmapmain.py:
the verion of minecraft whic loads a txt worldfile, probably generated from a heightmap image by heightmap.py

heightmap.py:
generates world txt files from heightmap images

README.txt:
this file

gradient.png:
Where the blocks in game get their texture

usa.jpg, world.jpg:
two example heightmap images to generate worlds from

usa.txt, world.txt:
two world files generated by heightmap.py from their respective images


HOW TO USE:

There are two main modes to use the package. First, you can generate worlds from predownloaded heightmap images. Or, you can generate the world dynamically as you walk around from data automatically donwloaded from the USGS SRTM dataset.

To use in the first mode, first get a grayscale heightmap image, such as usa.jpg. Then generate a .txt world file from it using heightmap.py. Specify the input image, the output path for the generated .txt world file, and the desired height and number of blocks of the generated world. Then, you can load this world in with python heightmapmain.py <.txt file>. Pretty much all we changed here was replacing _initialize() with load_from_txt()


To use the dynamic mode, just run python maindynamic.py.
This is basically how it works:
Every call to _update() in Window, check to see if the player is moving. If so, call the model's update_player_position(). In here, the model will check to see if the player is outside the loaded world area. If so, it will load a chunk of data centered on the player with 'radius' defined in self.LOAD_DISTANCE.

The scale of the model to real life can be modified with the MODEL_SCALE constant, and the player's starting coords with START_LON and START_LAT. Make sure that LON_OFFSET and LAT_OFFSET are fairly close to the starting position. else, the model coordinates will be large, and result in gl rendering floating point errors. You can set START_HEIGHT too. Model and real world heights are the same, in meters.

Deleting blocks from the world is really slow every time you load more blocks, but if you want, you can uncomment the call to clear_world() in load_world()

Check out the Rectangle and Area class, they are really pretty in how you use them to check loaded area



elevation.py is used in load_world(). It is fairly complicated. first, it determines which 1degree by 1degree tiles of SRTM data we are going to need. Then, it checks whether we've already downloaded the data, and uses the cached version if so. Otherwise, we need to download it fresh, so construct the right url, download the zip file, unzip it, and read the contents of the contained file. parse this raw data into a numpy array. Then, if the area that we requested overlaps multiple tiles, stitch together the tile data into one big array. Finally, return the right slice of the array that corresponds to the real world area requested.








